'use strict';

var assert = require('assert');
var util = require('util');

var Taf = require('@tencent/taf-rpc');
var TafConfigure = require('@tencent/taf-config-parser');
var TafStream = require('@tencent/taf-stream');

var PropertyPlusF = require('./PropertyPlusFProxy');

var POLICYFunc = require('../policy');

exports.LogAllotObj = 'WSDITIL.LogAllotServer4Comm.LogAllotObj';
exports.reportInterval = 10 * 1000;
exports.POLICY = POLICYFunc;
exports.RouterServer = {
	'pre' : 'pre.routerserver.seer.3g.qq.com',
	'test' : 'test.routerserver.seer.3g.qq.com',
	'formal' : 'routerserver.seer.3g.qq.com'
};

var TafClient;

var serverName, localIp, locator;

var emptyfn = function() {};

var data = {}, timer_id, client;

var ReportObj = function(policies, options) {
	var POLICY_lIST = [POLICYFunc.Sum, POLICYFunc.Avg, POLICYFunc.Max, POLICYFunc.Min, POLICYFunc.Count], _policies = policies;

	if (_policies) {
		if (!Array.isArray(_policies)) {
			_policies = [_policies];
		}
		assert(_policies.every(function(policy) { return POLICY_lIST.indexOf(policy) !== -1 }), 'every policy must be one of the Sum, Avg, Max, Min or Count');
	}

	this.policies = _policies;

	this._logs = {};
	this._boundary = '|';
	this._options = options;
};
ReportObj.prototype.report = function(keys, values) {
	var logKey, logObj;

	assert(Array.isArray(keys), 'keys must be an Array');
	assert(keys.every(function(key) { return typeof key === 'string' }), 'every item in keys must be an String');
	assert(Array.isArray(values), 'values must be an Array');

	logKey = keys.join(this._boundary);
	logObj = this._logs[logKey];

	if (!logObj) {
		if (!this.policies) {
			this.policies = values.map(function() {
				return POLICYFunc.Sum;
			});
		}

		logObj = {
			keys : this._options.notTafLog ? keys : [serverName, localIp].concat(keys),
			policies : this.policies.map(function(policy) {
				return new policy;
			})
		};

		this._logs[logKey] = logObj;
	}

	logObj.policies.forEach(function(policy, index) {
		if (!policy.add(values[index])) {
			policy.add(0);
		}
	});

	if (!timer_id) {
		timer_id = setTimeout(task, exports.reportInterval);
	}
};
ReportObj.prototype.get = function() {
	var ths = this;

	var result = Object.getOwnPropertyNames(this._logs).map(function(logKey) {
		var logObj = ths._logs[logKey], binBuffer = null;

		var StatContent = new PropertyPlusF.LogStat.StatContent;
		StatContent.keys.value = logObj.keys;

		logObj.policies.forEach(function(policy) {
			var StatValue = new PropertyPlusF.LogStat.StatValue;
			StatValue.count = 1;
			StatValue.value = policy.get() || 0;
			StatValue.policy = policy.name;
			StatContent.values.push(StatValue);
		});

		binBuffer = StatContent.toBinBuffer();
		
		return binBuffer._buffer.slice(0, binBuffer._length);
	});

	if (!this._options.cacheKeyPolicy) {
		this._logs = {};
	}

	return result;
};

var task = function() {
	var statlogs = new TafStream.List(PropertyPlusF.LogStat.StatLog);

	if (!client) {
		if (locator) {
			TafClient.setProperty('locator', locator);
		}
		client = TafClient.stringToProxy(PropertyPlusF.LogStat.PropertyPlushFProxy, exports.LogAllotObj);
	}

	Object.getOwnPropertyNames(data).forEach(function(logname) {
		var arr = data[logname].get(), stLogs;
		if (arr.length > 0) {
			stLogs = new PropertyPlusF.LogStat.StatLog;
			stLogs.logname = logname;
			stLogs.content.value = arr;

			statlogs.push(stLogs);
		}
	});

	if (statlogs.length > 0) {
		client.mutillogstat(statlogs).catch(emptyfn);
	}

	timer_id = undefined;
};

var init = function(obj) {
	var tafConfig, setdivision;

	obj = obj || process.env.TAF_CONFIG;

	assert(obj, 'TAF_CONFIG is not in env and init argument is neither an TAFConfigureObj nor a String.');
	
	if (typeof obj === 'string' && obj !== '') {
		TafClient.initialize(obj);
		tafConfig = new TafConfigure();
		tafConfig.parseFile(obj);
	} else {
		tafConfig = obj;
	}

	assert(typeof tafConfig === 'object', 'init argument not an TAFCnfigureObj');

	exports.LogAllotObj = tafConfig.get('taf.application.client.propertyplus', exports.LogAllotObj);

	if (!isNaN(parseInt(tafConfig.get('taf.application.client.report-interval')))) {
		exports.reportInterval = parseInt(tafConfig.get('taf.application.client.report-interval'));
	}

	serverName = tafConfig.get('taf.application.client.modulename');
	assert(serverName, 'moduleName not found in TAF_CONFIG(taf.application.client.modulename)');

	localIp = tafConfig.get('taf.application.server.localip');
	assert(localIp, 'localip not found in TAF_CONFIG(taf.application.server.localip)');

	setdivision = tafConfig.get('taf.application.setdivision');

	if (tafConfig.get('taf.application.enableset', '').toLowerCase() === 'y' && setdivision && typeof setdivision === 'string') {
		setdivision = setdivision.split('.');
		if (setdivision.length >= 3) {
			serverName += '.' + setdivision[0] + setdivision[1] + setdivision.slice(2).join('.');
		}
	}
};

exports.init = init;

exports.create = function(name, policies, options) {
	var logname, opt = options || {};

	assert(name, 'name must be a String');

	if (!TafClient) {
		TafClient = Taf.Communicator.New();
	}

	if (opt.notTafLog) {
		logname = (opt.prefix || 'opp') + '_' + name;
	} else {
		if (!serverName) {
			init();
		}
		logname = (opt.prefix || 'pp') + '_' + serverName + '_' + name;
	}

	if (exports.RouterServer.hasOwnProperty(opt.routerEnv)) {
		locator = util.format('Docker.DockerRegistry.QueryObj@tcp -h %s -p 9903 -t 50000', exports.RouterServer[opt.routerEnv]);
	}

	data[logname] = data[logname] || new ReportObj(policies, opt);

	return data[logname];
};