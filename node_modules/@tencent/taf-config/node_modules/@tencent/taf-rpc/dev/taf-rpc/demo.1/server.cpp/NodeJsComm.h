// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.2.1.4 by WSRD Tencent.
// Generated from `NodeJsComm.jce'
// **********************************************************************

#ifndef __NODEJSCOMM_H_
#define __NODEJSCOMM_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace TRom
{
    struct User_t : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TRom.User_t";
        }
        static string MD5()
        {
            return "72dfddf03422779b81fb661a3938fb92";
        }
        User_t()
        :id(0),score(0),name("")
        {
        }
        void resetDefautlt()
        {
            id = 0;
            score = 0;
            name = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(id, 0);
            _os.write(score, 1);
            _os.write(name, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, false);
            _is.read(score, 1, false);
            _is.read(name, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(score,"score");
            _ds.display(name,"name");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(score, true);
            _ds.displaySimple(name, false);
            return _os;
        }
    public:
        taf::Int32 id;
        taf::Int32 score;
        std::string name;
    };
    inline bool operator==(const User_t&l, const User_t&r)
    {
        return l.id == r.id && l.score == r.score && l.name == r.name;
    }
    inline bool operator!=(const User_t&l, const User_t&r)
    {
        return !(l == r);
    }

    struct Result_t : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "TRom.Result_t";
        }
        static string MD5()
        {
            return "feec12de7b13d3c49a37abb722ac4db4";
        }
        Result_t()
        :id(0),iLevel(0)
        {
        }
        void resetDefautlt()
        {
            id = 0;
            iLevel = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(id, 0);
            _os.write(iLevel, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, false);
            _is.read(iLevel, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(iLevel,"iLevel");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(iLevel, false);
            return _os;
        }
    public:
        taf::Int32 id;
        taf::Int32 iLevel;
    };
    inline bool operator==(const Result_t&l, const Result_t&r)
    {
        return l.id == r.id && l.iLevel == r.iLevel;
    }
    inline bool operator!=(const Result_t&l, const Result_t&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class NodeJsCommPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~NodeJsCommPrxCallback(){}
        virtual void callback_getUsrName(taf::Int32 ret,  const std::string& sValue1,  const std::string& sValue2)
        { throw std::runtime_error("callback_getUsrName() overloading incorrect."); }
        virtual void callback_getUsrName_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getUsrName_exception() overloading incorrect."); }

        virtual void callback_getall(taf::Int32 ret,  const TRom::Result_t& stResult)
        { throw std::runtime_error("callback_getall() overloading incorrect."); }
        virtual void callback_getall_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getall_exception() overloading incorrect."); }

        virtual void callback_secRequest(taf::Int32 ret,  const vector<taf::Char>& binResponse)
        { throw std::runtime_error("callback_secRequest() overloading incorrect."); }
        virtual void callback_secRequest_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_secRequest_exception() overloading incorrect."); }

        virtual void callback_test(taf::Int32 ret)
        { throw std::runtime_error("callback_test() overloading incorrect."); }
        virtual void callback_test_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_test_exception() overloading incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<NodeJsCommPrxCallback> NodeJsCommPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class NodeJsCommPrxCallbackPromise: public taf::ServantProxyCallback
    {
    public:
        virtual ~NodeJsCommPrxCallbackPromise(){}
    public:
        struct PromiseGetUsrName0: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            std::string sValue1;
            std::string sValue2;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0 > PromiseGetUsrName0Ptr;

        NodeJsCommPrxCallbackPromise(const promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr > &promise)
        : _promise_getusrname0(promise)
        {}
        
        virtual void callback_getUsrName(const NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr &ptr)
        {
            _promise_getusrname0.setValue(ptr);
        }
        virtual void callback_getUsrName_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:getUsrName_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getusrname0.setException(promise::copyException(str));
        }

    protected:
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr > _promise_getusrname0;

    public:
        struct PromiseGetall1: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            TRom::Result_t stResult;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< NodeJsCommPrxCallbackPromise::PromiseGetall1 > PromiseGetall1Ptr;

        NodeJsCommPrxCallbackPromise(const promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr > &promise)
        : _promise_getall1(promise)
        {}
        
        virtual void callback_getall(const NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr &ptr)
        {
            _promise_getall1.setValue(ptr);
        }
        virtual void callback_getall_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:getall_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getall1.setException(promise::copyException(str));
        }

    protected:
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr > _promise_getall1;

    public:
        struct PromiseSecRequest2: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            vector<taf::Char> binResponse;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< NodeJsCommPrxCallbackPromise::PromiseSecRequest2 > PromiseSecRequest2Ptr;

        NodeJsCommPrxCallbackPromise(const promise::Promise< NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr > &promise)
        : _promise_secrequest2(promise)
        {}
        
        virtual void callback_secRequest(const NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr &ptr)
        {
            _promise_secrequest2.setValue(ptr);
        }
        virtual void callback_secRequest_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:secRequest_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_secrequest2.setException(promise::copyException(str));
        }

    protected:
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr > _promise_secrequest2;

    public:
        struct PromiseTest3: virtual public TC_HandleBase
        {
        public:
            taf::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef taf::TC_AutoPtr< NodeJsCommPrxCallbackPromise::PromiseTest3 > PromiseTest3Ptr;

        NodeJsCommPrxCallbackPromise(const promise::Promise< NodeJsCommPrxCallbackPromise::PromiseTest3Ptr > &promise)
        : _promise_test3(promise)
        {}
        
        virtual void callback_test(const NodeJsCommPrxCallbackPromise::PromiseTest3Ptr &ptr)
        {
            _promise_test3.setValue(ptr);
        }
        virtual void callback_test_exception(taf::Int32 ret)
        {
            std::string str("");
            str += "Function:test_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_test3.setException(promise::copyException(str));
        }

    protected:
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseTest3Ptr > _promise_test3;

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<NodeJsCommPrxCallbackPromise> NodeJsCommPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class NodeJsCommCoroPrxCallback: public NodeJsCommPrxCallback
    {
    public:
        virtual ~NodeJsCommCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        virtual int onDispatch(taf::ReqMessagePtr msg);
    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef taf::TC_AutoPtr<NodeJsCommCoroPrxCallback> NodeJsCommCoroPrxCallbackPtr;

    /* proxy for client */
    class NodeJsCommProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::Int32 getUsrName(const std::string & sUsrName,std::string &sValue1,std::string &sValue2,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_getUsrName(NodeJsCommPrxCallbackPtr callback,const std::string & sUsrName,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr > promise_async_getUsrName(const std::string & sUsrName,const map<string, string> &context = TAF_CONTEXT());
        void coro_getUsrName(NodeJsCommCoroPrxCallbackPtr callback,const std::string & sUsrName,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getall(const TRom::User_t & stUser,TRom::Result_t &stResult,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_getall(NodeJsCommPrxCallbackPtr callback,const TRom::User_t & stUser,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr > promise_async_getall(const TRom::User_t & stUser,const map<string, string> &context = TAF_CONTEXT());
        void coro_getall(NodeJsCommCoroPrxCallbackPtr callback,const TRom::User_t & stUser,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 secRequest(const vector<taf::Char> & binRequest,vector<taf::Char> &binResponse,const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_secRequest(NodeJsCommPrxCallbackPtr callback,const vector<taf::Char> & binRequest,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr > promise_async_secRequest(const vector<taf::Char> & binRequest,const map<string, string> &context = TAF_CONTEXT());
        void coro_secRequest(NodeJsCommCoroPrxCallbackPtr callback,const vector<taf::Char> & binRequest,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 test(const map<string, string> &context = TAF_CONTEXT(),map<string, string> * pResponseContext = NULL);
        void async_test(NodeJsCommPrxCallbackPtr callback,const map<string, string> &context = TAF_CONTEXT());

        promise::Future< NodeJsCommPrxCallbackPromise::PromiseTest3Ptr > promise_async_test(const map<string, string> &context = TAF_CONTEXT());
        void coro_test(NodeJsCommCoroPrxCallbackPtr callback,const map<string, string> &context = TAF_CONTEXT());

        NodeJsCommProxy* taf_hash(int64_t key);
        NodeJsCommProxy* taf_set_timeout(int msecond);
        NodeJsCommProxy* taf_loaded();
    };
    typedef taf::TC_AutoPtr<NodeJsCommProxy> NodeJsCommPrx;

    /* servant for server */
    class NodeJsComm : public taf::Servant
    {
    public:
        virtual ~NodeJsComm(){}
        virtual taf::Int32 getUsrName(const std::string & sUsrName,std::string &sValue1,std::string &sValue2,taf::JceCurrentPtr current) = 0;
        static void async_response_getUsrName(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &sValue1, const std::string &sValue2);

        virtual taf::Int32 getall(const TRom::User_t & stUser,TRom::Result_t &stResult,taf::JceCurrentPtr current) = 0;
        static void async_response_getall(taf::JceCurrentPtr current, taf::Int32 _ret, const TRom::Result_t &stResult);

        virtual taf::Int32 secRequest(const vector<taf::Char> & binRequest,vector<taf::Char> &binResponse,taf::JceCurrentPtr current) = 0;
        static void async_response_secRequest(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<taf::Char> &binResponse);

        virtual taf::Int32 test(taf::JceCurrentPtr current) = 0;
        static void async_response_test(taf::JceCurrentPtr current, taf::Int32 _ret);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define TRom_User_t_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.id,b.id);jce_copy_struct(a.score,b.score);jce_copy_struct(a.name,b.name);

#define TRom_Result_t_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.id,b.id);jce_copy_struct(a.iLevel,b.iLevel);



#endif
