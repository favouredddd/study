/**
 * Created by czzou on 2018/11/19.
 */

var DELTA = 0x9e3779b9,SALT_LEN= 2,ZERO_LEN= 7,ROUNDS=16,LOG_ROUNDS=4;

//var DEBUG_RAND_ARR = [1804289383,846930886,1681692777,1714636915,1957747793,424238335,719885386,1649760492,596516649];
function rand(){
    //取得int8随机数
    //return DEBUG_RAND_ARR.shift() & 0x000000ff;
    return Math.floor((Math.random()) * 256) << 24 >> 24;
}

function TeaEncryptECB(pInBuf, pKey, pOutBuf,offset)
{
    var y, z, sum, i, k=[];
    /*plain-text is TCP/IP-endian;*/
    /*GetBlockBigEndian(in, y, z);*/
    y = pInBuf.readUInt32BE();
    z = pInBuf.readUInt32BE(4);
    /*TCP/IP network byte order (which is big-endian).*/
    for ( i = 0; i<4; i++)
    {
        /*now key is TCP/IP-endian;*/
        k[i] =pKey.readUInt32BE(4*i);
    }
    sum = 0;
    for (i=0; i<ROUNDS; i++)
    {
        sum += DELTA;
        y += ((z << 4)>>>0) + ((k[0] ^ z) >>> 0) + ((sum ^ (z >>> 5)) >>>0 ) + k[1];
        y = y >>> 0;
        z += ((y << 4)>>>0) + ((k[2] ^ y) >>>0 ) + ((sum ^ (y >>> 5)) >>>0 ) + k[3];
        z = z >>> 0;
    }
    pOutBuf.writeUInt32BE(y,offset)
    pOutBuf.writeUInt32BE(z, offset+4)
    /*now encrypted buf is TCP/IP-endian;*/
}

function TeaDecryptECB(pInBuf, pKey, pOutBuf)
{
    var y, z, sum;//uint32
    var k=[]; //unint32[]
    var i;

    y = pInBuf.readUInt32BE();
    z = pInBuf.readUInt32BE(4);

    for ( i=0; i<4; i++)
    {
        /*key is TCP/IP-endian;*/
        k[i] =pKey.readUInt32BE(4*i);
    }

    sum = DELTA << LOG_ROUNDS;
    for (i=0; i<ROUNDS; i++)
    {
        z -= ((y << 4)>>>0) + ((k[2] ^ y) >>>0 ) + ((sum ^ (y >>> 5)) >>>0 ) + k[3];
        z = z >>> 0;
        y -= ((z << 4)>>>0) + ((k[0] ^ z) >>> 0) + ((sum ^ (z >>> 5)) >>>0 ) + k[1];
        y = y >>> 0;
        sum -= DELTA;
    }

    pOutBuf.writeUInt32BE(y);
    pOutBuf.writeUInt32BE(z, 4);
    /*now plain-text is TCP/IP-endian;*/
}

/*
 输入:pInBuf为需加密的明文部分(Body),nInBufLen为pInBuf长度;
 输出:pOutBuf为密文格式,pOutBufLen为pOutBuf的长度是8byte的倍数;
 */
/*TEA加密算法,CBC模式*/
/*密文格式:PadLen(1byte)+Padding(var,0-7byte)+Salt(2byte)+Body(var byte)+Zero(7byte)*/
function encrypt(pKey, pInBuf)
{
    var nInBufLen = pInBuf.byteLength;
    var nPadSaltBodyZeroLen,nPadlen;
    var src_buf=Buffer.allocUnsafe(8), iv_plain=Buffer.alloc(8), iv_crypt;
    var src_i, i, j;

    /*根据Body长度计算PadLen,最小必需长度必需为8byte的整数倍*/
    nPadSaltBodyZeroLen = nInBufLen+1+SALT_LEN+ZERO_LEN;
    if((nPadlen=nPadSaltBodyZeroLen%8))
    {
        nPadlen=8-nPadlen;
    }
    var pOutBufLen = nPadSaltBodyZeroLen+nPadlen;
    var originBufLen = pOutBufLen;
    var pOutBuf = Buffer.alloc(pOutBufLen);

    /*加密第一块数据(8byte),取前面10byte*/
    src_buf[0] = (rand() & 0x0f8) | nPadlen;
    src_i = 1;

    while(nPadlen--){
        src_buf[src_i++]=rand();
    }
    iv_crypt = iv_plain;
    pOutBufLen = 0;

    for (i=1;i<=SALT_LEN;)
    {
        if (src_i<8)
        {
            src_buf[src_i++]=rand();
            i++;
        }

        if (src_i==8)
        {
            /*加密前异或前8个byte的密文(iv_crypt指向的)*/
            for (j=0;j<8;j++){
                src_buf[j]=(src_buf[j]^iv_crypt[j])>>>0;
            }
            TeaEncryptECB(src_buf, pKey, pOutBuf,pOutBufLen);
            /*pOutBuffer、pInBuffer均为8byte, pKey为16byte*/
            /*加密后异或前8个byte的明文(iv_plain指向的)*/
            for (j=0;j<8;j++){
                pOutBuf[j+pOutBufLen]=(pOutBuf[j+pOutBufLen]^iv_plain[j])>>>0;
            }
            /*保存当前的iv_plain*/
            for (j=0;j<8;j++){
                iv_plain[j]=src_buf[j];
            }
            /*更新iv_crypt*/
            src_i=0;
            iv_crypt=pOutBuf.slice(pOutBufLen,pOutBufLen+8);
            pOutBufLen+=8;
            //pOutBuf+=8;
            pOutBuf = Buffer.concat([pOutBuf, Buffer.alloc(8)]);
        }
    }

    /*src_i指向src_buf下一个位置*/
    var inBufIndex = 0;
    while(nInBufLen)
    {
        if (src_i<8)
        {
            //这里cpp中指针后移，但是因为之后再没有访问，所以不用处理
            src_buf[src_i++]=pInBuf[inBufIndex++];
            nInBufLen--;

        }
        if (src_i==8)
        {
            /*src_i==8*/
            /*加密前异或前8个byte的密文(iv_crypt指向的)*/
            for (j=0;j<8;j++) {
                src_buf[j]=(src_buf[j]^iv_crypt[j])>>>0;
            }

            TeaEncryptECB(src_buf, pKey, pOutBuf,pOutBufLen);
            /*加密后异或前8个byte的明文(iv_plain指向的)*/
            for (j=0;j<8;j++){
                pOutBuf[j+pOutBufLen]=(pOutBuf[j+pOutBufLen]^iv_plain[j])>>>0;
            }

            /*保存当前的iv_plain*/
            for (j=0;j<8;j++){
                iv_plain[j]=src_buf[j];
            }
            src_i=0;
            iv_crypt=pOutBuf.slice(pOutBufLen,pOutBufLen+8);
            pOutBufLen+=8;
            pOutBuf = Buffer.concat([pOutBuf, Buffer.alloc(8)]);
        }
    }

    /*src_i指向src_buf下一个位置*/
    for (i=1;i<=ZERO_LEN;)
    {
        if (src_i<8)
        {
            src_buf[src_i++]=0;
            i++; /*i inc in here*/
        }
        if (src_i==8)
        {
            /*src_i==8*/
            /*加密前异或前8个byte的密文(iv_crypt指向的)*/
            for (j=0;j<8;j++){
                src_buf[j]=(src_buf[j]^iv_crypt[j])>>>0;
            }
            TeaEncryptECB(src_buf, pKey, pOutBuf,pOutBufLen);
            /*加密后异或前8个byte的明文(iv_plain指向的)*/
            for (j=0;j<8;j++){
                pOutBuf[j+pOutBufLen]=(pOutBuf[j+pOutBufLen]^iv_plain[j])>>>0;
            }
            /*保存当前的iv_plain*/
            for (j=0;j<8;j++){
                iv_plain[j]=src_buf[j];
            }
            src_i=0;
            iv_crypt=pOutBuf.slice(pOutBufLen,pOutBufLen+8);
            pOutBufLen+=8;
            pOutBuf = Buffer.concat([pOutBuf, Buffer.alloc(8)])
        }
    }
    return pOutBuf.slice(0, originBufLen);
}

function decrypt(pKey, pInBuf){
    do{
        var nInBufLen = pInBuf.byteLength,pOutBufLen = 2*nInBufLen;
        var pOutBuf = Buffer.alloc(pOutBufLen);
        var nPadLen, nPlainLen;
        var dest_buf=Buffer.allocUnsafe(8), zero_buf=Buffer.alloc(8);
        var iv_pre_crypt, iv_cur_crypt;
        var dest_i, i, j;
        //const char *pInBufBoundary;
        var inBufPos=0,nBufPos = 0;
        if ((nInBufLen%8) || (nInBufLen<16)) break;
        TeaDecryptECB(pInBuf, pKey, dest_buf);
        nPadLen = dest_buf[0] & 0x7/*只要最低三位*/;
        /*明文长度*/
        i = nInBufLen-1-nPadLen-SALT_LEN-ZERO_LEN;
        if (pOutBufLen<i) break;
        pOutBufLen = i;
        iv_pre_crypt = zero_buf;
        iv_cur_crypt = pInBuf; /*init iv*/
        inBufPos += 8;
        nBufPos += 8;
        dest_i=1; /*dest_i指向dest_buf下一个位置*/
        /*把Padding滤掉*/
        dest_i+=nPadLen;
        for (i=1; i<=SALT_LEN;)
        {
            if (dest_i<8)
            {
                dest_i++;
                i++;
            }
            else if (dest_i==8)
            {
                /*解开一个新的加密块*/
                iv_pre_crypt = iv_cur_crypt;
                iv_cur_crypt = pInBuf.slice(inBufPos);
                /*异或前一块明文(在dest_buf[]中)*/
                for (j=0; j<8; j++)
                {
                    if( (nBufPos + j) >= nInBufLen) break;
                    dest_buf[j]= dest_buf[j] ^ pInBuf[inBufPos+j];
                }
                TeaDecryptECB(dest_buf, pKey, dest_buf);
                /*在取出的时候才异或前一块密文(iv_pre_crypt)*/
                inBufPos += 8;
                nBufPos += 8;
                dest_i=0;
            }
        }
        /*还原明文*/
        var leftOutBufLen = pOutBufLen;
        var pOutBufPos = 0;
        while (leftOutBufLen)
        {
            if (dest_i<8)
            {
                pOutBuf[pOutBufPos++]=dest_buf[dest_i]^iv_pre_crypt[dest_i];
                dest_i++;
                leftOutBufLen--;
            }
            else if (dest_i==8)
            {
                /*改变前一个加密块的指针*/
                iv_pre_crypt = iv_cur_crypt;
                iv_cur_crypt = pInBuf.slice(inBufPos);
                /*解开一个新的加密块*/
                for (j=0; j<8; j++)
                {
                    if( (nBufPos + j) >= nInBufLen) break;
                    dest_buf[j]^=pInBuf[inBufPos+j];
                }
                TeaDecryptECB(dest_buf, pKey, dest_buf);
                /*在取出的时候才异或前一块密文(iv_pre_crypt)*/
                inBufPos += 8;
                nBufPos += 8;
                dest_i=0; /*dest_i指向dest_buf下一个位置*/
            }
        }

        /*校验Zero*/
        for (i=1;i<=ZERO_LEN;)
        {
            if (dest_i<8)
            {
                if(dest_buf[dest_i]^iv_pre_crypt[dest_i]) break;
                dest_i++;
                i++;
            }
            else if (dest_i==8)
            {
                /*改变前一个加密块的指针*/
                iv_pre_crypt = iv_cur_crypt;
                iv_cur_crypt = pInBuf.slice(inBufPos);

                /*解开一个新的加密块*/
                /*异或前一块明文(在dest_buf[]中)*/
                for (j=0; j<8; j++)
                {
                    if( (nBufPos + j) >= nInBufLen) break;
                    dest_buf[j]^=pInBuf[inBufPos+j];
                }
                TeaDecryptECB(dest_buf, pKey, dest_buf);

                /*在取出的时候才异或前一块密文(iv_pre_crypt)*/
                inBufPos += 8;
                nBufPos += 8;
                dest_i=0; /*dest_i指向dest_buf下一个位置*/
            }
        }
        return pOutBuf.slice(0, pOutBufLen);
    } while(0);
    throw new Error("[TC_Tea::decrypt] decrypt error.");
}

module.exports = {
    encrypt:encrypt,
    decrypt:decrypt
}