// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.2.1.4 by WSRD Tencent.
// Generated from `NodeJsComm.jce'
// **********************************************************************

#include "NodeJsComm.h"
#include "jce/wup.h"
#include "servant/BaseF.h"

using namespace wup;

namespace TRom
{

    taf::Int32 NodeJsCommProxy::getUsrName(const std::string &sUsrName, std::string &sValue1, std::string &sValue2, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(sUsrName, 1);
        _os.write(sValue1, 2);
        _os.write(sValue2, 3);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"getUsrName", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(sValue1, 2, true);
        _is.read(sValue2, 3, true);
        return _ret;
    }

    void NodeJsComm::async_response_getUsrName(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &sValue1, const std::string &sValue2)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("sValue1", sValue1);
            tafAttr.put("sValue2", sValue2);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(sValue1, 2);

            _os.write(sValue2, 3);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void NodeJsCommProxy::async_getUsrName(NodeJsCommPrxCallbackPtr callback,const std::string &sUsrName,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(sUsrName, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getUsrName", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    promise::Future< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr > NodeJsCommProxy::promise_async_getUsrName(const std::string &sUsrName,const map<string, string>& context)
    {
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr > promise;
        NodeJsCommPrxCallbackPromisePtr callback = new NodeJsCommPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(sUsrName, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getUsrName", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    void NodeJsCommProxy::coro_getUsrName(NodeJsCommCoroPrxCallbackPtr callback,const std::string &sUsrName,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(sUsrName, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getUsrName", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    taf::Int32 NodeJsCommProxy::getall(const TRom::User_t &stUser, TRom::Result_t &stResult, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(stUser, 1);
        _os.write(stResult, 2);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"getall", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(stResult, 2, true);
        return _ret;
    }

    void NodeJsComm::async_response_getall(taf::JceCurrentPtr current, taf::Int32 _ret, const TRom::Result_t &stResult)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("stResult", stResult);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(stResult, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void NodeJsCommProxy::async_getall(NodeJsCommPrxCallbackPtr callback,const TRom::User_t &stUser,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(stUser, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getall", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    promise::Future< NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr > NodeJsCommProxy::promise_async_getall(const TRom::User_t &stUser,const map<string, string>& context)
    {
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr > promise;
        NodeJsCommPrxCallbackPromisePtr callback = new NodeJsCommPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(stUser, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getall", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    void NodeJsCommProxy::coro_getall(NodeJsCommCoroPrxCallbackPtr callback,const TRom::User_t &stUser,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(stUser, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"getall", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    taf::Int32 NodeJsCommProxy::secRequest(const vector<taf::Char> &binRequest, vector<taf::Char> &binResponse, const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(binRequest, 1);
        _os.write(binResponse, 2);
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"secRequest", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(binResponse, 2, true);
        return _ret;
    }

    void NodeJsComm::async_response_secRequest(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<taf::Char> &binResponse)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("binResponse", binResponse);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(binResponse, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void NodeJsCommProxy::async_secRequest(NodeJsCommPrxCallbackPtr callback,const vector<taf::Char> &binRequest,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(binRequest, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"secRequest", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    promise::Future< NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr > NodeJsCommProxy::promise_async_secRequest(const vector<taf::Char> &binRequest,const map<string, string>& context)
    {
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr > promise;
        NodeJsCommPrxCallbackPromisePtr callback = new NodeJsCommPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(binRequest, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"secRequest", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    void NodeJsCommProxy::coro_secRequest(NodeJsCommCoroPrxCallbackPtr callback,const vector<taf::Char> &binRequest,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(binRequest, 1);
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"secRequest", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    taf::Int32 NodeJsCommProxy::test(const map<string, string> &context,map<string, string> * pResponseContext)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        taf::ResponsePacket rep;
        std::map<string, string> _mStatus;
        taf_invoke(taf::JCENORMAL,"test", _os.getByteBuffer(), context, _mStatus, rep);
        if(pResponseContext)
        {
            *pResponseContext = rep.context;
        }

        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void NodeJsComm::async_response_test(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void NodeJsCommProxy::async_test(NodeJsCommPrxCallbackPtr callback,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback);
    }
    
    promise::Future< NodeJsCommPrxCallbackPromise::PromiseTest3Ptr > NodeJsCommProxy::promise_async_test(const map<string, string>& context)
    {
        promise::Promise< NodeJsCommPrxCallbackPromise::PromiseTest3Ptr > promise;
        NodeJsCommPrxCallbackPromisePtr callback = new NodeJsCommPrxCallbackPromise(promise);

        taf::JceOutputStream<taf::BufferWriter> _os;
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback);

        return promise.getFuture();
    }

    void NodeJsCommProxy::coro_test(NodeJsCommCoroPrxCallbackPtr callback,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        std::map<string, string> _mStatus;
        taf_invoke_async(taf::JCENORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback, true);
    }

    NodeJsCommProxy* NodeJsCommProxy::taf_hash(int64_t key)
    {
        return (NodeJsCommProxy*)ServantProxy::taf_hash(key);
    }

    NodeJsCommProxy* NodeJsCommProxy::taf_set_timeout(int msecond)
    {
        return (NodeJsCommProxy*)ServantProxy::taf_set_timeout(msecond);
    }

    NodeJsCommProxy* NodeJsCommProxy::taf_loaded()
    {
        return (NodeJsCommProxy*)ServantProxy::taf_loaded();
    }

    static ::std::string __TRom__NodeJsComm_all[]=
    {
        "getUsrName",
        "getall",
        "secRequest",
        "test"
    };

    const map<std::string, std::string> & NodeJsCommPrxCallback::getResponseContext() const
    {
        CallbackThreadData * pCbtd = CallbackThreadData::getData();
        assert(pCbtd != NULL);

        if(!pCbtd->getContextValid())
        {
            throw TC_Exception("cann't get response context");
        }
        return pCbtd->getResponseContext();
    }

    int NodeJsCommPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TRom__NodeJsComm_all, __TRom__NodeJsComm_all+4, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TRom__NodeJsComm_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getUsrName_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string sValue1;
                _is.read(sValue1, 2, true);
                std::string sValue2;
                _is.read(sValue2, 3, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_getUsrName(_ret, sValue1, sValue2);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getall_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TRom::Result_t stResult;
                _is.read(stResult, 2, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_getall(_ret, stResult);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_secRequest_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                vector<taf::Char> binResponse;
                _is.read(binResponse, 2, true);
                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_secRequest(_ret, binResponse);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_test_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                CallbackThreadData * pCbtd = CallbackThreadData::getData();
                assert(pCbtd != NULL);

                pCbtd->setResponseContext(msg->response.context);

                callback_test(_ret);

                pCbtd->delResponseContext();

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    int NodeJsCommPrxCallbackPromise::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TRom__NodeJsComm_all, __TRom__NodeJsComm_all+4, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TRom__NodeJsComm_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getUsrName_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                NodeJsCommPrxCallbackPromise::PromiseGetUsrName0Ptr ptr = new NodeJsCommPrxCallbackPromise::PromiseGetUsrName0();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->sValue1, 2, true);
                _is.read(ptr->sValue2, 3, true);

                ptr->_mRspContext = msg->response.context;

                callback_getUsrName(ptr);

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getall_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                NodeJsCommPrxCallbackPromise::PromiseGetall1Ptr ptr = new NodeJsCommPrxCallbackPromise::PromiseGetall1();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->stResult, 2, true);

                ptr->_mRspContext = msg->response.context;

                callback_getall(ptr);

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_secRequest_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                NodeJsCommPrxCallbackPromise::PromiseSecRequest2Ptr ptr = new NodeJsCommPrxCallbackPromise::PromiseSecRequest2();

                _is.read(ptr->_ret, 0, true);

                _is.read(ptr->binResponse, 2, true);

                ptr->_mRspContext = msg->response.context;

                callback_secRequest(ptr);

                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_test_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);

                NodeJsCommPrxCallbackPromise::PromiseTest3Ptr ptr = new NodeJsCommPrxCallbackPromise::PromiseTest3();

                _is.read(ptr->_ret, 0, true);


                ptr->_mRspContext = msg->response.context;

                callback_test(ptr);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    int NodeJsCommCoroPrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__TRom__NodeJsComm_all, __TRom__NodeJsComm_all+4, string(msg->request.sFuncName));
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TRom__NodeJsComm_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getUsrName_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string sValue1;
                _is.read(sValue1, 2, true);
                std::string sValue2;
                _is.read(sValue2, 3, true);
                setResponseContext(msg->response.context);

                callback_getUsrName(_ret, sValue1, sValue2);

                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getall_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                TRom::Result_t stResult;
                _is.read(stResult, 2, true);
                setResponseContext(msg->response.context);

                callback_getall(_ret, stResult);

                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_secRequest_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                vector<taf::Char> binResponse;
                _is.read(binResponse, 2, true);
                setResponseContext(msg->response.context);

                callback_secRequest(_ret, binResponse);

                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_test_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                setResponseContext(msg->response.context);

                callback_test(_ret);

                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    int NodeJsComm::onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer)
    {
        pair<string*, string*> r = equal_range(__TRom__NodeJsComm_all, __TRom__NodeJsComm_all+4, _current->getFuncName());
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __TRom__NodeJsComm_all)
        {
            case 0:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string sUsrName;
                std::string sValue1;
                std::string sValue2;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("sUsrName", sUsrName);
                    tafAttr.getByDefault("sValue1", sValue1, sValue1);
                    tafAttr.getByDefault("sValue2", sValue2, sValue2);
                }
                else
                {
                    _is.read(sUsrName, 1, true);
                    _is.read(sValue1, 2, false);
                    _is.read(sValue2, 3, false);
                }
                taf::Int32 _ret = getUsrName(sUsrName,sValue1,sValue2, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("sValue1", sValue1);
                        tafAttr.put("sValue2", sValue2);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(sValue1, 2);
                        _os.write(sValue2, 3);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                TRom::User_t stUser;
                TRom::Result_t stResult;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("stUser", stUser);
                    tafAttr.getByDefault("stResult", stResult, stResult);
                }
                else
                {
                    _is.read(stUser, 1, true);
                    _is.read(stResult, 2, false);
                }
                taf::Int32 _ret = getall(stUser,stResult, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("stResult", stResult);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(stResult, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                vector<taf::Char> binRequest;
                vector<taf::Char> binResponse;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("binRequest", binRequest);
                    tafAttr.getByDefault("binResponse", binResponse, binResponse);
                }
                else
                {
                    _is.read(binRequest, 1, true);
                    _is.read(binResponse, 2, false);
                }
                taf::Int32 _ret = secRequest(binRequest,binResponse, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("binResponse", binResponse);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(binResponse, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                }
                else
                {
                }
                taf::Int32 _ret = test(_current);                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }


}

