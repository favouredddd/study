'use strict';

var path = require('path'),
	util = require('util'),
	assert = require('assert'),
	cluster = require('cluster');

var TafConfigure = require('@tencent/taf-config-parser'),
	TafDyeing = require('@tencent/taf-dyeing');

var winston = require('winston'),
	winstonTaf = require('@tencent/winston-taf');

var callsite = require('callsite');

var cycle = require('cycle');

var tafConfig, initialized = false, listened = false, instances = {};

var LogTo = {
	Local : 1,
	Remote : 2,
	Both : 3
};

var lineno = function() {
	var stack = callsite()[3];
	return path.basename(stack.getFileName()) + ':' + stack.getLineNumber();
};

var getDyeingObj = function() {
	var val = arguments[0], key = arguments[1];

	if (!val) {
		return TafDyeing.gen(false);
	}

	if (TafDyeing.is(val)) {
		return val;
	}

	switch(typeof val) {
		case 'boolean' :  {
			return TafDyeing.gen(true);
		}
		case 'string' : {
			if (key && typeof key === 'string') {
				return TafDyeing.gen(true, key, val);
			} else {
				return TafDyeing.gen(true, null, val);
			}
		}
		case 'object' : {
			if (typeof val.getDyeingObj === 'function') {
				return val.getDyeingObj();
			}
			break;
		}
	}

	return TafDyeing.gen(false);
};

var setConfig = function(obj) {
	initialized = true;

	obj = obj || process.env.TAF_CONFIG;

	if (!obj) {
		return;
	}

	if (obj) {
		if (typeof obj === 'string') {
			tafConfig = new TafConfigure;
			tafConfig.parseFile(obj);
		} else if (obj instanceof TafConfigure) {
			tafConfig = obj;
		}
	}
};

var listenMessage = function() {
	listened = true;

	if (cluster.isWorker) {
		process.on('message', listenMessage.listener);
	}
};
listenMessage.listener = function(message) {
	if (message.cmd === 'taf.setloglevel' && message.data) {
		Object.getOwnPropertyNames(instances).forEach(function(key) {
			var instance = instances[key].obj;
			if (instance.type === 'TafRotate') {
				instance.setLevel(message.data);
			}
		});
	}
};

var setLogger = function(logger) {
	logger.setLevels(winston.config.taf.levels);
	logger.emitErrs = true;
};

var buildConsole = function(type, options) {
	var formatter;

	if (type === 'TafDate') {
		formatter = options.formatter || winstonTaf.Formatter.Simple({
			separ : options.separ
		});
	} else {
		formatter = options.formatter || winstonTaf.Formatter.Detail({
			separ : options.separ
		});
	}

	return new (winston.Logger)({transports : [new winston.transports.Console({
		formatter : formatter
	})]});
};

var tafLogs = function(type, name, options) {
	var ths = this;

	if (!(this instanceof tafLogs)) {
		return new tafLogs(type, name, options);
	}

	assert(winston.transports[type], 'argument type not found in winston.transports');

	assert(!name || typeof name === 'string', 'argument name MUST BE an string');

	if (instances[type + name]) {
		instances[type + name].ref += 1;
		return instances[type + name].obj;
	}

	if (!initialized) {
		setConfig();
	}

	if (!listened) {
		listenMessage();
	}

	options = options || {};

	if (!tafConfig) {
		this._commonLogger = buildConsole(type, options);
		setLogger(this._commonLogger);
		this.setLevel('INFO');
		return;
	}

	if (typeof options.hasSufix !== 'boolean') {
		options.hasSufix = true;
	}
	if (typeof options.hasAppNamePrefix !== 'boolean') {
		options.hasAppNamePrefix = true;
	}
	options.concatStr = options.concatStr || '_';

	assert(name || options.hasAppNamePrefix, 'name and options.hasAppNamePrefix can\'t be empty at the same time');

	if (type !== 'TafRemote') {
		if (options.hasAppNamePrefix) {
			options.filename = util.format('%s.%s', tafConfig.get('taf.application.server.app'), 
				tafConfig.get('taf.application.server.server'));
		} else {
			options.filename = '';
		}

		if (name) {
			options.filename += (options.hasAppNamePrefix ? options.concatStr : '') + name;
		}

		if (options.hasSufix) {
			options.filename += '.log';
		}

		options.filename = path.join(
			tafConfig.get('taf.application.server.logpath'), 
			tafConfig.get('taf.application.server.app'),
			tafConfig.get('taf.application.server.server'),
			options.filename
		);
	} else {
		options.filename = name;
	}

	this.type = type;
	this.name = name;
	this.options = options;

	if (type === 'TafDate') {
		this._initTafDate();
	} else {
		this._initCommon();
	}

	if (type !== 'TafRemote') {
		this._initDyeing();
	}

	if (type === 'TafRotate') {
		this.setLevel(tafConfig.get('taf.application.server.logLevel', 'DEBUG'));
	} else {
		this.setLevel('INFO');
	}

	instances[type + name] = {
		ref : 1,
		obj : this
	};
};

tafLogs.prototype._initDyeing = function() {
	this.options.filename = path.join(
		tafConfig.get('taf.application.server.logpath'),
		'taf_dyeing',
		'dyeing' + (this.options.hasSufix ? '.log' : '')
	);
	this.options.prefix = util.format('%s.%s', tafConfig.get('taf.application.server.app'), 
			tafConfig.get('taf.application.server.server'));

	this._dyeingLogger = new (winston.Logger)({
		transports : [
			new (winston.transports[this.type])(this.options)
		]
	});

	setLogger(this._dyeingLogger);
};

tafLogs.prototype._initCommon = function() {
	this.options.formatter = this.options.formatter || winstonTaf.Formatter.Detail({
		separ : this.options.separ
	});

	this._commonLogger = new (winston.Logger)({
		transports : [
			new (winston.transports[this.type])(this.options)
		]
	});

	setLogger(this._commonLogger);
};

tafLogs.prototype._initTafDate = function() {
	var transports = [];

	this.options.logTo = this.options.logTo || LogTo.Both;
	this.options.formatter = this.options.formatter || winstonTaf.Formatter.Simple({
		separ : this.options.separ
	});

	assert(Object.getOwnPropertyNames(LogTo).map(function(key) {
		return LogTo[key];
	}).indexOf(this.options.logTo) !== -1, 'LogTo NOT Valid');

	if (this.options.logTo !== LogTo.Local && this.options.format) {
		assert(this.options.format.name !== 'custom', 'options.format can\'t be custom in the case of LogTo.Both or Remote');
	}

	if (this.options.logTo === LogTo.Both || this.options.logTo === LogTo.Local) {
		transports.push(new (winston.transports.TafDate)(this.options));
	}

	this.options.filename = this.name;

	if (this.options.logTo === LogTo.Both || this.options.logTo === LogTo.Remote) {
		transports.push(new (winston.transports.TafRemote)(this.options));
	}

	this._commonLogger = new (winston.Logger)({transports : transports});

	setLogger(this._commonLogger);
};

tafLogs.prototype._log = function(level, args) {
	var dyeingObj, meta, addedLineno = false;

	if (args.length === 0) {
		return false;
	}

	dyeingObj = args[args.length - 1];

	if (TafDyeing.is(dyeingObj)) {
		args = Array.prototype.slice.call(args, 0, -1);

		if (args.length === 0) {
			return false;
		}

		if (!tafConfig || !dyeingObj.dyeing) {
			dyeingObj = undefined;
		}
	} else {
		args = Array.prototype.slice.call(args);
		dyeingObj = undefined;
	}

	meta = args[args.length - 1];
	if (meta && typeof meta === 'object') {
		if (meta.lineno !== false && this.type === 'TafRotate') {
			if (typeof meta.lineno !== 'string' || meta.lineno === '') {
				meta.lineno = lineno();
				addedLineno = true;
			}
		}

		if (!(meta instanceof Error) && !util.isDate(meta) && !Array.isArray(meta) && !util.isRegExp(meta) && !Buffer.isBuffer(meta)) {
			args[args.length - 1] = cycle.decycle(meta);
		}
	} else if (this.type === 'TafRotate') {
		args.push({
			lineno : lineno()
		});
	}

	if (dyeingObj) {
		this._dyeingLogger[level].apply(this._dyeingLogger, args);
	}

	this._commonLogger[level].apply(this._commonLogger, args);

	if (addedLineno) {
		delete meta.lineno;
	}

	return true;
};

tafLogs.prototype.debug = function() {
	var argsLen = arguments.length;
	var args = new Array(argsLen);
	for (var i = 0; i < argsLen; i += 1) {
		args[i] = arguments[i];
	}

	return this._log('debug', args);
};

tafLogs.prototype.info = function() {
	var argsLen = arguments.length;
	var args = new Array(argsLen);
	for (var i = 0; i < argsLen; i += 1) {
		args[i] = arguments[i];
	}

	return this._log('info', args);
};

tafLogs.prototype.warn = function() {
	var argsLen = arguments.length;
	var args = new Array(argsLen);
	for (var i = 0; i < argsLen; i += 1) {
		args[i] = arguments[i];
	}

	return this._log('warn', args);
};

tafLogs.prototype.error = function() {
	var argsLen = arguments.length;
	var args = new Array(argsLen);
	for (var i = 0; i < argsLen; i += 1) {
		args[i] = arguments[i];
	}

	return this._log('error', args);
};

tafLogs.prototype.setLevel = function(level) {
	var ths = this;

	if (typeof level !== 'string') {
		return false;
	}

	level = level.toLowerCase();

	if (Object.getOwnPropertyNames(winston.config.taf.levels).indexOf(level) === -1) {
		return false;
	}

	Object.getOwnPropertyNames(this._commonLogger.transports).forEach(function(name) {
		ths._commonLogger.transports[name].level = level;
	});
};

tafLogs.prototype.close = function() {
	this._commonLogger.close();

	if (this._dyeingLogger) {
		this._dyeingLogger.close();
	}

	if (instances[this.type + this.name]) {
		if (instances[this.type + this.name].ref > 1) {
			instances[this.type + this.name].ref -= 1;
		} else {
			delete instances[this.type + this.name];
		}
	}

	if (Object.getOwnPropertyNames(instances).length === 0) {
		if (cluster.isWorker) {
			process.removeListener('message', listenMessage.listener);
		}
		listened = false;
	}
};

tafLogs.prototype.getDyeingObj = getDyeingObj;

tafLogs.LogTo = LogTo;
tafLogs.DateFormat = winstonTaf.DateFormat;
tafLogs.Formatter = winstonTaf.Formatter;

tafLogs.setConfig = setConfig;

tafLogs.getDyeingObj = getDyeingObj;

module.exports = exports = tafLogs;