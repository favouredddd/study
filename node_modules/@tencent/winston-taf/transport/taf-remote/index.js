'use strict';

var util = require('util'),
	assert = require('assert');

var strftime = require('strftime');

var TafStream = require('@tencent/taf-stream'),
	TafClient = require('@tencent/taf-rpc').client,
	TafConfigure = require('@tencent/taf-config-parser');

var winston = require('winston'),
	common = require('winston/lib/winston/common');

var LogProxy = require('./LogProxy');

var TafDateFormat = require('../util/date-format');

var Formatter = require('../../lib/formatter');

var emptyfn = function() {};

var TafRemote = function(options) {
	var tafConfig;

	options = options || {};

	winston.Transport.call(this, options);

	assert(options.tafConfig || process.env.TAF_CONFIG, 'TAF_CONFIG is not in env and options.tafConfig not defined');

	if (options.tafConfig instanceof TafConfigure) {
		tafConfig = options.tafConfig;
	} else {
		if (typeof options.tafConfig === 'string') {
			tafConfig = new TafConfigure();
			tafConfig.parseFile(options.tafConfig);
		} else if (process.env.TAF_CONFIG) {
			tafConfig = new TafConfigure();
			tafConfig.parseFile(process.env.TAF_CONFIG);
		}
	}

	assert(tafConfig, 'options.tafConfig not instanceof taf-rpc.util.configure');

	assert(tafConfig.get('taf.application.server.app') && 
		tafConfig.get('taf.application.server.server'), 'app & server not found in configure file');

	this._logInfo = new LogProxy.taf.LogInfo();

	this._logInfo.appname = tafConfig.get('taf.application.server.app');
	this._logInfo.servername = tafConfig.get('taf.application.server.server');

	if (options.filename) {
		this._logInfo.sFilename = options.filename;
	}

	options.format = options.format || TafDateFormat.LogByDay;

	if (typeof options.format === 'function') {
		options.format = new options.format;
	}

	assert(options.format.name === 'day' || 
		options.format.name === 'hour' || 
		options.format.name === 'minute', 'options.format MUST be among [day|hour|minute]');

	this._logInfo.sFormat = options.format.logPattern;
	this._logInfo.sLogType = options.format.interval + options.format.name;

	if (tafConfig.get('taf.application.enableset', 'n').toLowerCase() === 'y' && 
		tafConfig.get('taf.application.setdivision', 'NULL') !== 'NULL') {
		this._logInfo.setdivision = tafConfig.get('taf.application.setdivision');
	}

	if (typeof options.hasSufix === 'boolean') {
		this._logInfo.bHasSufix = options.hasSufix;
	}
	if (typeof options.hasAppNamePrefix === 'boolean') {
		this._logInfo.bHasAppNamePrefix = options.hasAppNamePrefix;
	}
	if (typeof options.concatStr === 'string') {
		this._logInfo.sConcatStr = options.concatStr;
	}
	if (typeof options.separ === 'string') {
		this._logInfo.sSepar = options.separ;
	}

	if (typeof options.tafConfig === 'string') {
		TafClient.initialize(options.tafConfig);
	}

	if (typeof options.tafLogServant === 'string') {
		this._client = TafClient.stringToProxy(LogProxy.taf.LogProxy, options.tafLogServant);
	} else {
		this._client = TafClient.stringToProxy(LogProxy.taf.LogProxy, 
			tafConfig.get('taf.application.server.log', 'taf.taflog.LogObj'));
	}
	
	this.options = {
		interval : options.interval || 500, // 500ms
		bufferSize : options.bufferSize || 10000,
		prefix : options.prefix,
		formatter : options.formatter || Formatter.Detail({
			separ : this._logInfo.sSepar
		})
	};

	this._buffer = [];
	this._bufferIndex = 0;
};

util.inherits(TafRemote, winston.Transport);

TafRemote.prototype.name = 'tafRemote';

TafRemote.prototype.log = function (level, msg, meta, callback) {
	var ths = this;

	var output = common.log({
		level : level,
		message : msg,
		meta : meta,
		formatter : this.options.formatter,
		prefix : this.options.prefix
	}) + '\n';

	this._buffer[this._bufferIndex++] = {
		output : output,
		callback : callback
	};

	if (this._bufferIndex > this.options.bufferSize) {
		this._bufferIndex = 0;
	}

	if (!this._timerid) {
		this._timerid = setTimeout(function() {
			ths._flush();
			delete ths._timerid;
		}, this.options.interval);
	}
};

TafRemote.prototype._flush = function() {
	var buffer = new TafStream.List(TafStream.String), i = 0;

	for (i = this._bufferIndex; i < this._buffer.length; i += 1) {
		buffer.push(this._buffer[i].output);
		this._buffer[i].callback(null, true);
	}
	for (i = 0; i < this._bufferIndex; i += 1) {
		buffer.push(this._buffer[i].output);
		this._buffer[i].callback(null, true);
	}

	this._bufferIndex = 0;
	this._buffer = [];

	this._client.loggerbyInfo(this._logInfo, buffer).catch(emptyfn);
};

TafRemote.prototype.close = function() {
	if (this._timerid) {
		clearTimeout(this._timerid);
		delete this._timerid;
	}

	this._buffer = [];
	this._bufferIndex = 0;

	this._client.disconnect();
};

TafRemote.FORMAT = TafDateFormat;

module.exports = winston.transports.TafRemote = TafRemote;