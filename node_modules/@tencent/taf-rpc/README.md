# @tencent/taf-rpc

`@tencent/taf-rpc` 是 TAF RPC 调用框架，提供了一个多服务器（进程）间进行 RPC 调用的基础设施，它可以实现下述能力：

- 使用 [jce2node](https://git.code.oa.com/taf/jce2node) 将 Jce 文件翻译成客户端代理类代码后，供客户端调用任意的 TAF 服务。

- 使用 [jce2node](https://git.code.oa.com/taf/jce2node) 将 Jce 文件翻译成服务端代码后，可以实现标准的 TAF 服务，该服务可被任意使用 TAF/WUP 协议的客户端直接调用。

- 远程日志、染色日志、属性上报、告警上报与服务通信等框架内服务。

- 创建自定义通信协议的客户端代理类（比如使用 JSON 格式的协议）。

- 创建自定义通信协议的服务端（比如使用 JSON 格式的协议）。

- 模块：@tencent/taf-registry，功能：根据服务 Obj 名字到主控查询该服务可用的 IP 列表。

TAF RPC 分为客户端和服务器端两个部分：

* 客户端：提供了 RPC 代理生成，消息路由和网络通讯等功能。

* 服务器端：提供了远程服务暴露，请求派发，网络通讯等功能。

## 安装

```bash
tnpm install @tencent/taf-rpc
```

## 关于协议与 Jce 文件的说明

**在深入学习相关知识之前，我们先理清`JCE 编码协议`、`WUP 组包协议`、`TAF 组包协议`三者之间的关系：**

- JCE 编码协议是一种数据编解码规则，它将整形、枚举值、字符串、序列、字典、自定义结构体等数据类型按照一定的规则编码到二进制数据流中。对端接收到二进制数据流之后，按照相应的规则反序列化可得到原始数值。

- JCE 编码协议使用一种叫做 TAG 的整型值（unsigned char）来标识变量。 比如某个变量的 TAG 值为 100（该值由开发者自定义），编码时将变量值编码的同时，也将该 TAG 值编码进去。对端需要读取变量的数值时，就到数据流中寻找 TAG 值为 100 的数据段，找到后按规则读出数据部分即是变量的数值。

- JCE 编码协议的定位是一套编码规则。JCE 协议序列化之后的数据不仅可以进行网络传输，同时还可以存储到数据库。

- WUP 组包协议是 JCE 编码协议的上层封装，定位为通信协议。它使用变量名作为变量的关键字，编码时，将变量名打包到数据流中；解码时，根据变量名寻找对应的数据区，然后根据数据类型对该数据区进行反序列化得到原始数值。

- WUP 组包协议内置一个 JCE 编码协议的 <Map> 类型，该 <Map> 的键就是变量名，值是变量的数据值经过 JCE 编码序列化的二进制数据。

- WUP 组包协议封装的数据包可以直接发送给 TAF 服务端，而服务端可以直接反序列化得到原始值。

- TAF 组包协议是对 RequestPacket（请求结构体）和 ResponsePacket（结果结构体）使用 JCE 编码协议封装的通信协议。结构体包含比如请求序列号、协议类型、RPC 参数序列化之后二进制数据等重要信息。

JCE 编码协议的编解码规则以及 Jce 文件的编写方法，请参考 [KM文档 - wup-使用指南与规范](http://km.oa.com/group/taf/article_view/25529)。

模块不仅支持 `TAF/WUP/JCE` 调用，还支持 [自定义通讯协议](#自定义通讯协议) 调用。

### 转换工具

使用时，可以根据需求定义通信描述文件 Jce，然后通过下述工具转换出所需的代码文件：

* [NodeTools](http://git.code.oa.com/taf/node-agent/tree/master) （推荐）

* [Jce2node](http://git.code.oa.com/taf/jce2node)

## 示例

编写 Jce 文件，定义客户端与服务端通信用到的常量、枚举值、结构体、函数等通信协议。

> 一般而言 Jce 文件通常由`服务端开发`制定、维护和提供。

使用如下文件 (NodeJsComm.jce) 作为示例：

```c++
module TRom
{
    struct User_t
    {
        0 optional int id = 0;
        1 optional int score = 0;
        2 optional string name = "";
    };

    struct Result_t
    {
        0 optional int id = 0;
        1 optional int iLevel = 0;
    };

    interface NodeJsComm
    {
        int getAll(User_t stUser, out Result_t stResult);
    };
};
```

### 服务端

1. 使用 [转换工具](#转换工具) 转换 JCE 生成服务端代码。

2. 填补 `NodeJsCommImp.js` 文件中定义的 RPC 函数，实现自己的业务逻辑。

```javascript
var TRom = require('./NodeJsComm.js').TRom;
module.exports.TRom = TRom;

TRom.NodeJsCommImp.prototype.initialize = function () {
    //TODO
};

TRom.NodeJsCommImp.prototype.getAll = function (current, stUser, stResult) {
    //
    // 初始时，每个RPC函数都为空，需要开发者自己完形填空，补齐这里缺失的业务逻辑。
    // 补齐业务逻辑之后，开发者调用 current 的 sendResponse 函数，返回数据给调用方。
    // 需要注意：每个函数的 sendResponse 都是不一样的，它的参数与当前函数的 返回值 和 出参 相对应。
    //         如果当前函数有返回值，那么 current.sendResponse 的第一个参数应该是该返回。示例中当前函数的返回值为 int 类型，我们返回 200 作为示例。
    //         解决返回值的问题之后，我们按顺序写入当前的出参即可。参数的编解码和网络传输由框架解决。
    //

    stResult.id     = 10000;
    stResult.iLevel = 10001;

    current.sendResponse(200, stResult);
};
```

3. 创建服务入口文件（主要负责读取配置文件、配置端口、设置协议解析器、启动服务等），即可启动服务端。

```javascript
var Taf  = require("@tencent/taf-rpc").server;
var TRom = require("./NodeJsCommImp.js").TRom;

var svr  = Taf.createServer(TRom.NodeJsCommImp);
svr.start({
    name     : "TRom.NodeJsTestServer.NodeJsCommObjAdapter",
    servant  : "TRom.NodeJsTestServer.NodeJsCommObj",
    endpoint : "tcp -h 127.0.0.1 -p 14002 -t 10000",
    protocol : "taf",
    maxconns : 200000
});
```

### 客户端

1. 使用 [转换工具](#转换工具) 转换 JCE 生成客户端代码。

2. 编写客户端代码（如下）即可调用服务端。

```javascript
var Taf  = require("@tencent/taf-rpc").client;
var TRom = require("./NodeJsCommProxy.js").TRom;

//生成服务端调用代理类实例
var prx = Taf.stringToProxy(TRom.NodeJsCommProxy, "TRom.NodeJsTestServer.NodeJsCommObj@tcp -h 127.0.0.1 -p 14002 -t 60000");

//客户端调用采用 Promise 机制进行回调，这里编写成功以及失败的回调函数
var success = function (result) {
    console.log("result.response.costtime:",            result.response.costtime);
    console.log("result.response.return:",              result.response.return);
    console.log("result.response.arguments.stResult:",  result.response.arguments.stResult);
}

var error = function (result) {
    console.log("result.response.costtime:",            result.response.costtime);
    console.log("result.response.error.code:",          result.response.error.code);
    console.log("result.response.error.message:",       result.response.error.message);
}

//初始化接口参数，调用 RPC 接口
var stUser = new TRom.User_t();
stUser.name = "tencent-mig";

prx.getAll(stUser).then(success, error);
```
## 客户端相关配置

### 初始化

__如果服务在 TAF 平台上运行（或在 `stringToProxy` 时指定 IP 调用），则无需执行该方法。__

初始化是通过调用特定模块的 `initialize(data)` 方法实现，data 为 TAF 配置文件路径。

除了使用 `initialize(data)` 方法外，我们还可以调用 `set(key, value)` 方法进行设置：

```javascript
var Taf  = require("@tencent/taf-rpc").client;

Taf.setProperty("locator", "taf.tafregistry.QueryObj@tcp -h 172.27.208.171 -p 17890");
Taf.setProperty("timeout", 60000);
```

### 请求参数

客户端代理对象调用协议接口函数时，最后一个参数可以传入配置对象：

* dyeing：请求染色对象，详见 [@tencent/taf-dyeing](http://tnpm.oa.com/package/@tencent/taf-dyeing)。

* context：请求上下文对象。

* packetType：请求类型参数，1 为单向请求，其他为普通请求

* hashCode：请求 hash，必须填入js精度安全范围内的数字（Math.pow(2, 53) - 1）

* consistentHash: 一致性 hash，可传入任意字符串或者 js 精度安全范围内数字

### 哈希（hash）调用

如果想要请求根据某个特征来发到某台固定的机器，可以使用如下方法：

``` javascript
prx.getUsrName(param,{
    hashCode: userId
}).then(success, error).done();
```

获得客户端代理对象之后，调用服务端接口函数，此时可以传入 hashCode 参数，客户端会根据 hashCode 来把请求分配到连接列表中固定的一台机器。

需要注意的是：

* hashCode 需为 `Number` 类型，但请注意 ECMAScript 处理高精度数字存在的精度丢失问题。

* 服务端列表固定时，同一 hashCode 会被分配到固定的对端节点，当服务端列表发生变化时，会重新分配对端节点。

### 一致性哈希

要使用一致性哈希，可以在获取代理对象时，加上如下配置
```javascript
Taf.stringToProxy(Taf.ServantProxy, "APP.XXXServer.XXXObj", { bEnableConsistentHash: true })
```
调用时，按下面的方式传入哈希字符，支持字符串或者数字，当传入字符时，会根据字符计算哈希寻找节点；传入数字时，直接将其作为哈希结果寻找节点。
``` javascript
prx.getUsrName(param, {
    consistentHash: "xxxxxx"
}).then(success, error).done();

```

### wup调用
当需要使用 rpc 模块发起 wup 协议的调用时，可按以下方式设置协议版本：

| 协议版本 | 协议名      |
| -------- | ----------- |
| 1        | jce         |
| 2        | wup-complex |
| 3        | wup-simple  |


```javascript
var prx = Taf.stringToProxy(Taf.ServantProxy, "APP.XXXServer.XXXObj")
prx.setVersion(2)
```


### 设置异常节点屏蔽策略参数

满足下述条件时会认为对端节点异常：

* 60 秒内，超时调用次数大于等于 2，超时比率大于 0.5

* 连续超时次数大于 5

异常节点将会被屏蔽，并每隔 30 秒重试，如果成功则恢复。

若需要修改屏蔽策略，可调用 `setCheckTimeoutInfo` 方法，如下：

```javascript
proxy._worker.setCheckTimeoutInfo({
    minTimeoutInvoke     : 2,      //策略1的最小超时次数
    checkTimeoutInterval : 60000,  //策略1的最小时间间隔，单位ms
    frequenceFailInvoke  : 5,      //策略2的连续超时次数
    minFrequenceFailTime : 5000,   //策略2的最小间隔时间(从第0次到第5次超时的最小间隔时间)，单位ms
    radio                : 0.5,    //策略1的超时比率
    tryTimeInterval      : 30000   //重试时间间隔，单位ms
})
```

### 调用完成事件在进程间同步

如果服务通过 [node-agent](http://git.code.oa.com/taf/node-agent/tree/master "node-agent") （或在 TAF 平台）运行，可能会创建多个业务进程，此时异常节点屏蔽策略会在各个进程里边各自执行。

如开启 8 个业务进程时，需要 40 个超时才能将所有进程中的异常节点设置为不可用，若调用流量较小，则需要很长的时间才能完全屏蔽。

对于可用性要求高的服务，可通过 `setSyncInvokeFinish(true)` 开启业务进程间调用结果同步（如下）：

```javascript
proxy._worker.setSyncInvokeFinish(true)
```

在相同的场景下，此时只需要 5 次超时调用就能将 8 个业务进程里边的异常节点屏蔽。

**此特性会消耗 13% ~ 20% 性能，所以推荐流量很小、可用性要求高的业务开启。**

### RPC鉴权
若被调RPC节点需要鉴权，则客户端需要在私有模板中配置 `accesskey`、`secretkey`，否则与被调节点建立连接后鉴权无法通过，连接会直接被断开，私有模板配置示例：

```
<taf>
    <application>
        <client>
            <TRom.NodeTafServer.NodeTafObj>
                accesskey=test
                secretkey=123456
            </TRom.NodeTafServer.NodeTafObj>
        </client>
    </application>
</taf>
```

其中 `TRom.NodeTafServer.NodeTafObj` 是需要鉴权的 servant 名，需要修改为对应的业务 Obj。

### RPC调用错误码说明


| 错误码 | 说明                      |
| ------ | ------------------------- |
| 0      | 调用成功                  |
| -1     | 服务端解码错误            |
| -2     | 服务端编码错误            |
| -3     | 服务端找不到对应的函数    |
| -4     | 服务端找不到对应的servant |
| -6     | 服务端队列超时            |
| -9     | 服务端过载                |
| -10    | 找不到服务端节点          |
| -10000 | 服务端节点中无可用节点    |
| -11000 | 客户端编码错误            |
| -13001 | 客户端调用超时            |

### 实现原理

![客户端系统架构](http://git.code.oa.com/taf/taf-rpc/raw/master/doc/client.png)

## 服务端相关配置

### 创建方法

在 TAF 运维管理平台配置服务的 Obj，服务启动时由 tafnode 生成包含监听端口的配置文件，然后服务框架再依赖该配置绑定端口与启动服务。

![TAF Servant 配置](http://git.code.oa.com/taf/taf-rpc/raw/master/doc/objs.png)

### 使用配置文件启动服务

我们使用该配置文件创建一个服务，代码如下：

```javascript
var Taf       = require("@tencent/taf-rpc");
var TRom      = require("./NodeJsCommImp.js");

//创建一个服务的实例
//注意这里的配置，在正式环境时，用 process.env.TAF_CONFIG 来表示配置文件的路径
//也就是：svr.initialize(process.env.TAF_CONFIG, function (server){ ... });
var svr = new Taf.server();
svr.initialize("./TRom.NodeJsTestServer.config.conf", function (server){
    server.addServant(TRom.NodeJsCommImp, server.Application + "." + server.ServerName + ".NodeJsCommObj");
});

svr.start();
```

### 使用配置文件，并从中选取部分 Obj 启动服务

```javascript
var Taf   = require("@tencent/taf-rpc");
var TRom  = require("./NodeJsCommImp.js");

Taf.server.getServant("./TRom.NodeJsTestServer.config.conf").forEach(function (config){
    var svr, map;
    map = {
        'TRom.NodeJsTestServer.NodeJsCommObj' : TRom.NodeJsCommImp
    };

    svr = Taf.server.createServer(map[config.servant]);
    svr.start(config);
});
```

### 不使用配置文件，显示启动服务

```javascript
var Taf  = require("@tencent/taf-rpc").server;
var TRom = require("./NodeJsCommImp.js").TRom;

//创建一个服务的实例
//注意这里的 endpoint 和 protocol 为必选项，格式必须如下示例相同
var svr  = Taf.createServer(TRom.NodeJsCommImp);
svr.start({
    name     : "TRom.NodeJsTestServer.AdminObjAdapter",
    servant  : "TRom.NodeJsTestServer.AdminObj",
    endpoint : "tcp -h 127.0.0.1 -p 14002 -t 10000",
    maxconns : 200000,
    protocol : "taf"
});
```

### RPC鉴权
**启用鉴权**

taf-rpc 支持 servant 级别的鉴权，可以为每个 servant 配置不同的鉴权参数。若要开启 servant 鉴权，可以在 servant 的 endpoint 后加上 `-e 鉴权类型`，如：
```
TRom.NodeJsTestServer.AdminObj@tcp -h 10.165.13.6 -p 10069 -t 60000 -e 1
```
其中，-e 的选项：

```
// 认证类型：
enum AUTH_TYPE
{
    AUTH_TYPENONE   = 0,    // 无
    AUTH_TYPELOCAL  = 1,    // 业务server本地鉴权
    AUTH_TYPEANONY  = 2     // 鉴权允许匿名
};
```

AUTH_TYPELOCAL 时，若客户端连接鉴权未通过，则直接断开连接，服务端会打出对应鉴权错误的 error code。
AUTH_TYPEANONY 时，若客户端连接鉴权未通，客户端仍然发起调用，但是无法通过 JceCurrent 的 getUserId 获取用户身份；若鉴权通过，则业务代码通过 userId 做更细致的权限判断：

```javascript
TRom.NodeTafImp.prototype.getAll = function (current, stUser, stResult) {
    var userId = current.getUserId();
    //TODO: 根据 userId 做权限判断
}
```

**accesskey/secretkey 配置**

目前支持两种方式：
- 在配置文件中直接设置自定义的 ak/hex (sha1(hex(sha1(sk))))
- 在Auth服务中注册 ak/sk，然后在私有模板中配置 AuthLocator

第一种方式，要注意填写的 sk 是原始 secretkey 两次 sha1 后的 hex 字符串：第一次 hash 后输入 hex 字符，然后求 hex 字符的 hash，然后输出 hex。

```
<taf>
  <application>
    <server>
      <TRom.NodeTafServer.NodeTafObjAdapter>
        accesskey=test
        secretkey=69c5fcebaa65b560eaf06c3fbeb481ae44b8d618 #hex(sha1(sha1(123456)))
      </TRom.NodeTafServer.NodeTafObjAdapter>
    </server>
  </application>
</taf>
```

第二种方式，Auth服务需要实现 `core/auth/Auth.jce` 协议，框架会自动定期从 AuthLocator 拉取最新的 ak/sk，其中 ak/sk 注册接口为 `applySecret`。注意：如果设置了 AuthLocator，则更新 ak/sk 时会覆盖第一种方式设置的 ak/sk。
```
<taf>
  <application>
    <server>
      authlocator=taf.tafauth.AuthObj
    </server>
  </application>
</taf>
```

**鉴权错误码**

鉴权失败时，taf server 会打印出对应的 error code，类型如下：

```
// 认证状态：
enum AUTH_STATE
{
    AUTH_INIT               = -127, // 鉴权的初始状态
    AUTH_SUCC               = 0,    // 鉴权成功完成
    AUTH_WAIT_RSP           = 127,  // 等待AUTH服务鉴权返回

    AUTH_PROTO_ERR          = -100, // 协议错误
    AUTH_WRONG_OBJ          = -101, // obj错误
    AUTH_WRONG_AK           = -102, // AK
    AUTH_WRONG_TIME         = -103, // 错误的时间戳
    AUTH_NOT_SUPPORT_ENC    = -104, // 不支持的加解密方法
    AUTH_DEC_FAIL           = -105, // 解密失败,可能是密钥错误
    AUTH_ERROR              = -106, // 鉴权错误
    // 其它正数 : 认证的中间状态，用户自定义; 
    // 其它负数 : 认证的失败状态，用户自定义;
};
```




### 实现原理

![服务端系统架构](http://git.code.oa.com/taf/taf-rpc/raw/master/doc/server.png)

## 自定义通讯协议

首先双方先确定通信协议，比如我们以 `JSON` 作为通信协议，假定：

```javascript
//客户端 --> 服务端
{
    P_RequestId : 0,                    //本次调用的序列号
    P_FuncName  : 'test'                //本次调用的函数名称
    P_Arguments : ['aa', 'bb'.....]     //本次调用的函数参数
}

//客户端 <-- 服务端
{
    P_RequestId : 0,                    //本次调用的序列号
    P_FuncName  : 'test'                //本次调用的函数名称
    P_Arguments : ['ee', 'ff'.....]     //本次调用的返回参数
}
```

基于定义的协议，实现协议解析类（Protocol.js）：

```javascript
var EventEmitter = require("events").EventEmitter;
var util         = require("@tencent/util");

var stream = function () {
    EventEmitter.call(this);
    this._data = undefined;
    this._name = "json";
}
util.inherits(stream, EventEmitter);

stream.prototype.__defineGetter__("name", function () { return this._name; });

module.exports = stream;

/**
 * 根据传入数据进行打包的方法
 * @param request
 * request.iRequestId : 框架生成的请求序列号
 * request.sFuncName  : 函数名称
 * request.Arguments  : 函数的参数列表
 */
stream.prototype.compose = function (data) {
    var str = JSON.stringify({
        P_RequestId : data.iRequestId,
        P_FuncName  : data.sFuncName,
        P_Arguments : data.Arguments
    });

    var len = 4 + Buffer.byteLength(str);
    var buf = new Buffer(len);
    buf.writeUInt32BE(len, 0);
    buf.write(str, 4);

    return buf;
}

/**
 *
 * 网络收取包之后，填入数据判断是否完整包
 * @param data 传入的data数据可能是TCP的各个分片，不一定是一个完整的数据请求，协议解析类内部做好数据缓存工作
 *
 * 当有一个完整的请求时，解包函数抛出事件，需按照如下格式补充事件的数据成员：
 *
 * {
 *     iRequestId: 0,   // 本次请求的序列号
 *     sFuncName: "",   // 本次请求的函数名称
 *     Arguments: []    // 本次请求的参数列表
 * }
 *
 */
stream.prototype.feed = function (data) {
    var BinBuffer = data;
    if (this._data != undefined) {
        var temp = new Buffer(this._data.length + data.length);
        this._data.copy(temp, 0);
        data.copy(temp, this._data.length);
        this._data = undefined;
        BinBuffer = temp;
    }

    for (var pos = 0; pos < BinBuffer.length; ) {
        if (BinBuffer.length - pos < 4) {
            break;
        }
        var Length = BinBuffer.readUInt32BE(pos);
        if (pos + Length > BinBuffer.length) {
            break;
        }
        var result   = JSON.parse(BinBuffer.slice(pos + 4, pos + Length).toString());
        var request  =
        {
            iRequestId : result.P_RequestId,
            sFuncName  : result.P_FuncName,
            Arguments  : result.P_Arguments
        };

        this.emit("message", request);
        pos += Length;
    }

    if (pos != BinBuffer.length) {
        this._data = new Buffer(BinBuffer.length - pos);
        BinBuffer.copy(this._data, 0, pos);
    }
}

/**
 * 重置当前协议解析器
 */
stream.prototype.reset = function () {
    delete this._data;
    this._data = undefined;
}
```

### 客户端

客户端使用协议解析器，调用服务端：

```javascript
var Taf      = require("@tencent/taf-rpc").client;
var Protocol = require("./ProtocolClient.js");

var prx      = Taf.stringToProxy(Taf.ServantProxy, "test@tcp -h 127.0.0.1 -p 12306 -t 60000");
prx.setProtocol(Protocol);
prx.rpc.createFunc("echo");

var success = function (result) {
    console.log("success");
    console.log("result.response.costtime:",  result.response.costtime);
    console.log("result.response.arguments:", result.response.arguments);
}

var error = function (result) {
    console.log("error");
    console.log("result.response.error.code:",    result.response.error.code);
    console.log("result.response.error.message:", result.response.error.message);
}

prx.rpc.echo("tencent", "mig", "abc").then(success, error);
```

### 服务端

实现 RPC 函数处理类，并框架分发逻辑：

* 如果客户端传来的函数名，是处理类的函数，那么框架有限调用对应函数；

* 如果客户端传来的函数不是处理的函数，那么调用该处理类的 `onDispatch` 函数，由该函数负责处理该请求；

* 如果也没有 `onDispatch` 函数，则报错；

```javascript
// EchoHandle.js
var Handle = function () {}

Handle.prototype.echo = function (current, v1, v2, v3) {
    console.log("EchoHandle.echo::", v1, v2, v3);

    current.sendResponse("TX", "TX-MIG");
}

Handle.prototype.onDispatch = function (v1, v2, v3) {
    console.log("EchoHandle.onDispatch::", v1, v2, v3);
}

module.exports = Handle;
```

服务端启动代码示例：

```javascript
var Taf         = require("@tencent/taf-rpc").server;
var Protocol    = require("./ProtocolClient.js");
var Handle      = require("./EchoHandle.js");

var svr = Taf.createServer(Handle);
svr.start({
    endpoint : "tcp -h 127.0.0.1 -p 12306 -t 10000",
    protocol : Protocol
});
```