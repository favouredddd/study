var crypto = require("crypto");

function Server(endpoint, vnodesNumber){
    this.endpoint     = endpoint;
    this.vnodesNumber = vnodesNumber;
}
Server.prototype.toString = function () {
    return this.endpoint.toString();
}

function RingNode(hashvalue, server) {
    this.value = hashvalue;
    this.server = server;
}

function getUInt32(a, b, c, d) {
    return ((a << 24) | (b << 16) | (c << 8) | d) >>> 0;
}

function getHashBuffer(key) {
    var hash = crypto.createHash("md5").update(key +"").digest();
    if ("string" !== typeof hash) return hash;
    return hash.split("").map(function(char) {
        return char.charCodeAt(0);
    });
}

function hashValue(key) {
    var x = getHashBuffer(key);
    return getUInt32(x[3], x[2], x[1], x[0]);
}

function ConsistentHash(endpointInfoArr, options){
    options = options || {};
    this._vNodeNumber = options.hasOwnProperty("vNodeNumber") ? options["vNodeNumber"] : 100;
    this._ring = [];
    this._serverMap = {};
    this._ringSize = 0;
    this._serverSize = 0;
    this.addEndpoints(endpointInfoArr);
    //生成ring中的节点，根据ip port生成ring中的key和节点
    this._createRing();
}

ConsistentHash.prototype._reset = function() {
    this._ring.length = 0;
    this._ringSize = 0;
    this._serverSize = 0;
    return this;
}

/**
 * 生成ring
 * @returns {this}
 */
ConsistentHash.prototype._createRing = function() {
    var serverMap = this._serverMap, self = this, index = 0;

    var serverSize = Object.keys(serverMap).length
    if (serverSize === 0) return this;
    for(var key in serverMap){
        var hashBuffer, server = serverMap[key];
        //根据key计算得到hash数组，然后把hash buffer根据副本数分成4份，每份通过位运算得到一个Int32，作为key，存入ring数组
        for (var i = 0; i < server.vnodesNumber; i++) {
            hashBuffer = getHashBuffer(key +"-"+ i);
            for (var j = 0; j < 4; j++) {
                hash = getUInt32(hashBuffer[3 + j * 4], hashBuffer[2 + j * 4], hashBuffer[1 + j * 4], hashBuffer[j * 4]);
                self._ring[index] = new RingNode(hash, server);
                index++;
            }
        }
    }
    // 将ring中的节点按hash值由大到小排个序
    this._ring = this._ring.sort(function(a, b) {
        if (a.value === b.value) return 0;
        else if (a.value > b.value) return 1;
        return -1;
    });
    this._ringSize = this._ring.length;
    this._serverSize = serverSize;
    return this;
}

/**
 * 通过hash值折半查找距离最近的节点
 * 返回满足要求节点在ring中的index
 */
ConsistentHash.prototype._findPosition = function (hash) {
    var ring = this._ring, high = this._ringSize, low = 0, middle, prev, mid;
    while (true) {
        mid = (low + high) >> 1; //中间index
        if (mid === this._ringSize) return 0;
        middle = ring[mid].value;
        prev = mid === 0 ? 0 : ring[mid - 1].value;
        if (hash <= middle && hash > prev) return mid;
        if (middle < hash) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
        if (low > high) return 0;
    }
}

/**
 * 添加节点列表，重置ring并重新生成ring
 */
ConsistentHash.prototype.addEndpoints = function (endpointInfoArr) {
    if(!endpointInfoArr || endpointInfoArr.length === 0) return this;
    var self = this;
    endpointInfoArr.forEach(function (endpointInfo) {
        var key = endpointInfo.endpoint.toString();
        if(!self._serverMap[key]){
            self._serverMap[key] = new Server(endpointInfo.endpoint, endpointInfo.vNodeNumber || self._vNodeNumber);
        }
    })
    this._reset();
    return this._createRing();
};

ConsistentHash.prototype.removeEndpoints = function(endpoints) {
    if(!endpoints || endpoints.length === 0) return this;
    var self = this;
    endpoints.forEach(function (endpoint) {
        var key = endpoint.toString();
        delete self._serverMap[key];
    })
    this._reset();
    return this._createRing();
}

/**
 * 获取key对应的那个节点，然后按顺序向后获得server
 */
ConsistentHash.prototype.getEndPoints = function (key, size, unique) {
    if (!this._ringSize) return [];

    size = size || this._serverSize;
    unique = unique || "undefined" === typeof unique;
    var hash = "number" === typeof key && !isNaN(key) ? key : hashValue(key);
    var position = this._findPosition(hash), length = this._ringSize, endpoints = [], ringNode;

    for (var i = position; i < length; i++) {
        ringNode = this._ring[i];
        if (unique) {
            if (endpoints.indexOf(ringNode.server.endpoint) < 0) endpoints.push(ringNode.server.endpoint);
        } else {
            endpoints.push(ringNode.server.endpoint);
        }
        if (endpoints.length === size) return endpoints;
    }
    for (i = 0; i < position; i++) {
        ringNode = this._ring[i];
        if (unique) {
            if (endpoints.indexOf(ringNode.server.endpoint) < 0) endpoints.push(ringNode.server.endpoint);
        } else {
            endpoints.push(ringNode.server.endpoint);
        }

        if (endpoints.length === size) return endpoints;
    }
    return endpoints;
}

ConsistentHash.prototype.destroy = function () {
    this._reset();
    this._serverMap = {};
    return this;
}

module.exports = ConsistentHash;