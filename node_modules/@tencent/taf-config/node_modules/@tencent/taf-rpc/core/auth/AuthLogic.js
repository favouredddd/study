var crypto = require("crypto")
var TafStream = require("@tencent/taf-stream");
var tea       = require("../auth/tea");
var Auth = require("../auth/AuthProxy").taf;

function getHash(str,hashType){
    hashType = hashType ? hashType : "sha1"
    var hash=crypto.createHash(hashType);
    return hash.update(str).digest()
}

function AuthLogic(){
    this.AUTH_TYPE = Auth.AUTH_TYPE;
    this.AUTH_STATE = Auth.AUTH_STATE;
    this.BasicAuthInfo = Auth.BasicAuthInfo;
    this.BasicAuthPackage = Auth.BasicAuthPackage;
}

AuthLogic.prototype.defaultCreateAuthReq = function(stBasicAuthInfo){
    var secret1 = getHash(stBasicAuthInfo.sSecretKey, "sha1").toString("hex");
    var now = Math.floor(new Date().getTime()/1000);
    var tmp = Buffer.alloc(8);
    var secret2,tmpKey;
    secret2 = Buffer.from(getHash(secret1, "sha1").toString("hex"));
    tmp.writeUInt32LE(now, 0);
    for(var i=0;i<tmp.length;i++){
        secret2[i] = secret2[i] | tmp[i];
    }
    tmpKey = getHash(secret2, "md5");
    var secret1Enc = tea.encrypt(tmpKey,Buffer.from(secret1));
    var stBasicAuthPackage = new Auth.BasicAuthPackage();
    stBasicAuthPackage.readFromObject({
        sObjName: stBasicAuthInfo.sObjName,
        sAccessKey: stBasicAuthInfo.sAccessKey,
        iTime: now,
        sSignature: secret1Enc
    });
    return stBasicAuthPackage.toBinBuffer();
}

AuthLogic.prototype.defaultProcessAuthReq = function (sBuffer, adapter) {
    if(sBuffer.length <= 20){
        return Auth.AUTH_STATE.AUTH_PROTO_ERR;
    }
    var stBasicAuthPackage;
    //解码鉴权包
    try{
        var is = new TafStream.JceInputStream(sBuffer);
        stBasicAuthPackage = Auth.BasicAuthPackage.create(is);
    } catch (e){
        console.warning("[TAF] adapter " + adapter.name +" set userId fail after auth, this is only for taf proto ");
        return Auth.AUTH_STATE.AUTH_PROTO_ERR;
    }

    var stBasicAuthInfo = new Auth.BasicAuthInfo();
    stBasicAuthInfo.sObjName = adapter.servantName;
    stBasicAuthInfo.sAccessKey = stBasicAuthPackage.sAccessKey;
    stBasicAuthInfo.sHashSecretKey2 = adapter.getSk(stBasicAuthInfo.sAccessKey);
    if (!stBasicAuthInfo.sHashSecretKey2){
        return Auth.AUTH_STATE.AUTH_WRONG_AK;
    }

    if(stBasicAuthPackage.sObjName != stBasicAuthInfo.sObjName){
        return Auth.AUTH_STATE.AUTH_WRONG_OBJ;
    }

    var diff = new Date().getTime()/1000 - stBasicAuthPackage.iTime;
    if (Math.abs(diff) > 60*60){
        return Auth.AUTH_STATE.AUTH_WRONG_TIME;
    }

    //解密，校验
    var tmp = Buffer.alloc(8),tmpKey, secret1;
    var secret2 = Buffer.from(stBasicAuthInfo.sHashSecretKey2);
    tmp.writeUInt32LE(stBasicAuthPackage.iTime, 0);
    for(var i=0;i<tmp.length;i++){
        secret2[i] = secret2[i] | tmp[i];
    }
    tmpKey = getHash(secret2, "md5");

    try{
        secret1 = tea.decrypt(tmpKey, stBasicAuthPackage.sSignature.toNodeBuffer());
    } catch (e){
        return Auth.AUTH_STATE.AUTH_DEC_FAIL;
    }

    var clientSecret2 = getHash(secret1, "sha1").toString("hex");
    if (clientSecret2 !== stBasicAuthInfo.sHashSecretKey2){
        return Auth.AUTH_STATE.AUTH_ERROR;
    }

    return Auth.AUTH_STATE.AUTH_SUCC;
}

AuthLogic.prototype.refreshAksk = function(objs, application){
    if(!objs || !objs.length){
        return;
    }
    var stAkRequest = new Auth.AkRequest();
    stAkRequest.readFromObject({
        vObjName: objs
    });
    application.getUpdateAkskProxy().refreshAk(stAkRequest).then(function (data) {
        var vAkResponse = data.response.return;
        vAkResponse.forEach(function (stAkResponse) {
            var bindAdapter = application.getBindAdapterByName(stAkResponse.sObjName);
            if(bindAdapter){
                bindAdapter.updateAuthKeyMap(stAkResponse.mAkSk.toObject());
            }
        })
    }).catch(function (err) {
        console.error("[TAF] update aksk err with code:",err.response.error.code);
    })

}


var stAuthLogic = new AuthLogic();
module.exports = stAuthLogic;
