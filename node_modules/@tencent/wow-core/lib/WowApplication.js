/**
 * @author : pigozhu
 * @desc :
 */
const KoaApplication = require("koa")
const TafStarter = require("./starter/taf_starter")
const debug = require("debug")
const TafLog = require("@tencent/weplus-taf-logs")
const assert = require("assert")

class WowApplication extends KoaApplication {
  /**
   * options :
   *
   * @param {Object} options
   * @param {String} options.type = [TAF | WEB | BOTH]
   */
  constructor(options = {}) {
    super()
    if (options.TAF) {
      assert(options.TAF.servants)
      this._servants = options.TAF.servants
      this._servants.forEach(item => {
        assert.notDeepStrictEqual(item.objName, undefined)
        assert.notDeepStrictEqual(item.impl, undefined)
        assert.notDeepStrictEqual(item.port, undefined)
        assert.notDeepStrictEqual(item.host, undefined)
      })
    }
    this._type = options.type || "WEB"
    this._logger = new TafLog("TafDate", this.constructor.name)
    this._errorHandler = options.errorHandler
    this._before = options.before // 在项目启动时执行，比如读取配置文件后再启动
  }

  async start() {
    if (this._before && typeof this._before === "function") {
      await this._before()
    }
    await this._pruneStart()
  }

  async _pruneStart() {
    switch (this._type.toUpperCase()) {
      case "WEB":
        this._startWeb()
        break
      case "TAF":
        this.tafStarter = new TafStarter(this._servants)
        this._startTaf()
        break
      case "BOTH":
        this.tafStarter = new TafStarter(this._servants)
        this._startWeb()
        this._startTaf()
        break
      default:
        throw new Error("invalid start type")
    }
  }

  use(fn) {
    if (typeof fn === "object" && fn.hasOwnProperty("dispatch") && fn.hasOwnProperty("proxy")) {
      fn = fn.dispatch
    }
    return super.use(fn)
  }

  _startWeb() {
    const port = this._normalizePort(process.env.PORT || "3000")

    let server = this.listen(port)

    server.on("error", this._onError(server, this, port))
    server.on("listening", this._onListening(server))
  }

  _startTaf() {
    this.tafStarter.start()
  }

  /**
   *
   * @param val
   * @returns {*}
   * @private
   */
  _normalizePort(val) {
    let port = parseInt(val, 10)

    if (isNaN(port)) {
      // named pipe
      return val
    }

    if (port >= 0) {
      // port number
      return port
    }

    return false
  }

  /**
   *
   * @param error
   * @private
   */
  _onError(server, context, port) {
    return error => {
      if (error.syscall !== "listen") {
        throw error
      }

      let bind = typeof port === "string" ? "Pipe " + port : "Port " + port

      // handle specific listen errors with friendly messages
      switch (error.code) {
        case "EACCES":
          console.error(bind + " requires elevated privileges")
          process.exit(1)
          break
        case "EADDRINUSE":
          port += 1
          console.error(bind + " is already in use,will use " + port + " to retry")
          server = context.listen(port)
          server.on("error", context._onError(server, context, port))
          server.on("listening", context._onListening(server))
          break
        default:
          throw error
      }
    }
  }

  /**
   *
   * @private
   */
  _onListening(server) {
    return () => {
      let addr = server.address()
      let bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port
      this._logger.info("=============== The Server is listening on", bind, "===============")
      debug("Listening on " + bind)
    }
  }
}

module.exports = WowApplication
