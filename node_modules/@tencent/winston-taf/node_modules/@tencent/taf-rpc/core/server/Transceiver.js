/**
 * 服务端网络传输层代理类
 *
 * KevinTian@tencent.com
 * 2015-06-15
 */
///////////////////////////////////////////////TCP网络传输类////////////////////////////////////////////////////////////
var TafStream = require("@tencent/taf-stream");
var ProtoMessage = require("./ProtoMessage.js");
var AuthLogic = require("../auth/AuthLogic");
var AUTH_TYPE = AuthLogic.AUTH_TYPE;
var AUTH_STATE = AuthLogic.AUTH_STATE;

var TCPTransceiver = function () {
    this.adapter     = undefined;
    this.socket      = undefined;
    this.stream      = undefined;
    this.netthread   = undefined;
    this.uid         = 0;
    this._socket_evt = undefined;
    this._iTimeout   = 60000;
    this._authState     = AUTH_STATE.AUTH_INIT;
    this._userId      = undefined; //鉴权后的userid
};
module.exports.TCPTransceiver = TCPTransceiver;

TCPTransceiver.prototype.initialize = function () {
    var self = this;

    self._socket_evt = {
        close   : function()        { self.close(); },
        error   : function()        { self.close(); },
        timeout : function ()       { self.close(); },
        data    : function(data)    {self.stream.feed(data);},
        message : function(request) {
            //若需要鉴权，处理鉴权请求，否则处理业务请求
            if(!self.adapter.endpoint.hasOwnProperty("iAuthType") || self.adapter.endpoint.iAuthType == AUTH_TYPE.AUTH_TYPENONE || self._authState == AUTH_STATE.AUTH_SUCC){
                self.adapter.dispatch(self, request);
            } else {
                self._doAuthProcess(request)
            }
        }
    };

    self.socket.on("data",    self._socket_evt.data);
    self.socket.on("error",   self._socket_evt.error);
    self.socket.on("close",   self._socket_evt.close);
    self.socket.on("timeout", self._socket_evt.timeout);
	self.stream.on("error",   self._socket_evt.error);
    self.stream.on("message", self._socket_evt.message);

    self.socket.setTimeout(this._iTimeout);
};

TCPTransceiver.prototype.getUserId = function (){
    return this._userId;
}

TCPTransceiver.prototype._doAuthProcess = function (request) {
    var self = this;
    var bindAdapter=  self.adapter;
    var isAnony = !self.adapter.endpoint.hasOwnProperty("iAuthType") || self.adapter.endpoint.iAuthType == AUTH_TYPE.AUTH_TYPEANONY;
    if(!Object.keys(bindAdapter.authKeyMap).length && !isAnony){
        self.close();
        return;
    }
    var authFn = bindAdapter._authFn || AuthLogic.defaultProcessAuthReq;

    try{
        if(bindAdapter.isTafProtocol()){
            self._authState = authFn(request.origin.sBuffer, bindAdapter);
        } else {
            self._authState = authFn(request);
        }
    } catch(e){
        self._authState = AUTH_STATE.AUTH_DEC_FAIL;
    }

    if(self._authState != AUTH_STATE.AUTH_SUCC){
        //是否允许匿名
        if(isAnony){
            console.info("[TAF] adapter " + bindAdapter.name +" auth fail with code " + self._authState+" , but it allow anony");
            self._authState = AUTH_STATE.AUTH_SUCC;
        } else {
            console.error("[TAF] adapter " + bindAdapter.name +" auth fail with code " + self._authState);
            self.close();
            return;
        }
    } else if(!isAnony){
        try{
            var is = new TafStream.JceInputStream(request.origin.sBuffer);
            var stBasicAuthPackage = AuthLogic.BasicAuthPackage.create(is);
            self._userId = stBasicAuthPackage.sAccessKey;
        } catch (e){
            console.warn("[TAF] adapter " + bindAdapter.name +" set userId fail after auth, this is only for taf proto ", e.message);
        }
    }

    //发送鉴权成功的响应包
    var response = new ProtoMessage.Response();
    response.origin       = request.origin;
    response.iResultCode  = 0;
    response.sResultDesc  = "AUTH SUCC";
    console.info("[TAF] adapter " + bindAdapter.name + " auth success");
    self.send(response);
}

TCPTransceiver.prototype.close = function () { //主动或者发生错误之后，关闭本连接
    if (this.socket) {
        try
        {
            this.netthread.remove(this.uid);

            this.socket.removeListener("error",     this._socket_evt.error);
            this.socket.removeListener("close",     this._socket_evt.close);
            this.socket.removeListener("data",      this._socket_evt.data);
            this.socket.removeListener("timeout",   this._socket_evt.timeout);
			this.stream.removeListener("error",     this._socket_evt.error);
            this.stream.removeListener("message",   this._socket_evt.message);
            this.socket.destroy();

            this.socket = undefined;
        }catch(e){
            console.error('[TCPTransceiver.close] ' + e.message);
        }
    }
};

TCPTransceiver.prototype.send = function ($protoMessage) {
    if(this.socket)
        this.socket.write(this.stream.compose($protoMessage));
};

TCPTransceiver.prototype.setTimeout = function ($iTimeout) { //设置服务端连接空闲时间
    this._iTimeout = $iTimeout;
};

///////////////////////////////////////////////UDP网络传输类////////////////////////////////////////////////////////////
var UDPTransceiver = function () {
    this.adapter   = undefined;
    this.socket    = undefined;
    this.stream    = undefined;
    this.endpoint  = undefined;

    this._iTimeout = 60000;
};
module.exports.UDPTransceiver = UDPTransceiver;

UDPTransceiver.prototype.doRequest = function ($msg) {
    var self = this;

    self.stream.reset();
	self.stream.on("error", function (){});
    self.stream.on("message", function (request) { self.adapter.dispatch(self, request); });
    self.stream.feed($msg);
};

UDPTransceiver.prototype.send = function ($protoMessage) {
    var NodeBuffer = this.stream.compose($protoMessage);

    this.socket.send(NodeBuffer, 0, NodeBuffer.length, this.endpoint.iPort, this.endpoint.sHost);
};

UDPTransceiver.prototype.setTimeout = function ($iTimeout) { //设置服务端连接空闲时间
    this._iTimeout = $iTimeout;
};

UDPTransceiver.prototype.close = function () {

};